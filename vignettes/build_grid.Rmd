---
title: "How to easily build a prediction grid with the dshm R-package"
author: "Filippo Franchini"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dpi=300
)

load("/Users/User/Desktop/dshm/data/depth_crop.rda")
load("/Users/User/Desktop/dshm/data/land_crop.rda")
load("/Users/User/Desktop/dshm/data/empty_grid.rda")
load("/Users/User/Desktop/dshm/data/grid_final.rda")
```

## Summary

In this tutorial you will learn how to use the `dshm` R-package to:

- Create a prediction grid
- Fill the grid with relevant information such as covariate statisitcs.

## Create a grid

You can create an empty grid using the function `dshm_make_grid` as follows:

    empty_grid<-dshm_make_grid(extent = raster::extent(depth_crop),cell.size = 1000,projection =    raster::crs(depth_crop))
    
You just created a grid with cell size of 1 km (i.e. 1000 m), the extent and projection of the raster `depth_crop`. You can plot the grid using the following code:

    raster::plot(depth_crop, main="Depth + empty grid")
    raster::plot(land_crop,col="grey",add=TRUE)
    raster::plot(empty_grid,add=TRUE)
    
```{r, echo=FALSE, out.width = "300px",fig.height=6,fig.width=6}
raster::plot(depth_crop,main="Depth + empty grid")
raster::plot(land_crop,col="grey",add=TRUE)
raster::plot(empty_grid,add=TRUE)
```

As you may notice the upper part of the depth raster is not covered by grid cells. This is because, given the specified extent, there is not enough space for a 1x1 km grid cell. Here, we do not care about this problem but if you want to be picky you always have to design your grid bigger than the area in which you want to do your predictions.

## Correcting and Filling the Grid

Now, we will correct the grid cells for land and we will add covariate statistics using the function `dshm_fill_grid` as follows:

    grid_final<-dshm_fill_grid(empty.grid = empty_grid,
      land.data = land_crop,
      cov = list(depth=depth_crop,
      DR=DR_crop,
      DC=DC_crop),
      fun = mean,
      ncores = 7)

The function works only in parallel with at least 2 cores (i.e. almost all computers). This is because, depending on the raster resolution and the number of grid cells, the tasks requires a lot of time-consuming computations. The parallelization divides the grid into smaller parts that are given to different cores. In the function you can specify the arguments: `empty.grid` (i.e. the grid created with the function `dshm_make_grid`), `cov` (i.e. a list of covariate rasters), `fun` (i.e. the function to calculate covariate statisitcs within each grid cell), and `ncores` (i.e. the number of cores).

After running the function `dshm_fill_grid` you can visualize the final grid by typing:

    raster::plot(grid_final)
    
```{r, echo=FALSE, out.width = "300px",fig.height=6,fig.width=6}
raster::plot(grid_final)
```

As well as check the related data by typing:

    head(round(grid_final@data,2), 6)
    
You should get something like this:
 
```{r, echo=FALSE, results='asis',fig.height=6,fig.width=6}
knitr::kable(head(round(grid_final@data,2), 6))
```

For each grid cell you have the `id`, the centroids `x` and `y` coordinates, `area` in km$^2$, and all the covariates: in this case `depth`, distance to river (`DR`) and to coast (`DC`), in meters.
