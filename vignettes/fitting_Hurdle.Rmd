---
title: "Fitting Hurdle Models with the dshm R-Package"
author: "Filippo Franchini"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dpi=300
)

load("/Users/User/Desktop/dshm/data/obsdata.rda")
load("/Users/User/Desktop/dshm/data/mod_hr.rda")
load("/Users/User/Desktop/dshm/data/H_m.rda")
load("/Users/User/Desktop/dshm/data/grid_final.rda")
load("/Users/User/Desktop/dshm/data/pred.rda")
load("/Users/User/Desktop/dshm/data/pred_lwr.rda")
load("/Users/User/Desktop/dshm/data/pred_upr.rda")
load("/Users/User/Desktop/dshm/data/land_crop.rda")
```

## Summary

In this tutorial you will learn how to use the `dshm` R-package to:

- Fit Hurdle models.
- Explore estimated relationships.
- Run diagnostics tool on fitted models.
- Plot model predictions.
- Bootstrap confidence intervals.
- Investigate spatial correlation.

## Fit Hurdle Models

The dataset `obsdata` is an observation dataset containing information for dolphin sightings. Each row represents a sighting with information about `size` (i.e. number of dolphins); `distance` (i.e. the perpendicular distance in km from the transect line); `Latitude` and `Longitude` in degrees (i.e. coordinates); and finally `Sample.Label`, `Transect.Label` and `Region.Label` (i.e. the segment, transect and stratum where the sighting is located, respectively).

```{r, echo=FALSE, results='asis',fig.height=6,fig.width=6}
knitr::kable(head(obsdata, 6))
```

We can use the `obsdata` dataset to fit a detection function as follows:

    mod_hr <- Distance::ds(data = obsdata, transect = "line",
              key = "hr", adjustment = NULL, truncation = max(obsdata$distance))

The code you just used creates a `ds` object by fitting a hazard-rate detection function to the distances in `obsdata`. The detection function is used in the function `dshm_fit` to correct animal abundance for imperfect detection away from the transect line. You can then plot the fitted detection function:

```{r, echo=FALSE, out.width = "300px",fig.height=6,fig.width=6}
plot(mod_hr, showpoints = FALSE)
```

The `mod_hr` can be used to fit the Hurdle model using the function `dshm_fit`, but first we need to specify the variants for each of the two Hurdle submodels (presence-absence and abundance-given-presence):

    variants.pa <- c("s(DC,bs='cs')",
                  "s(DR,bs='cs')",
                  "s(depth,bs='cs')")

    variants.ab <- c("s(DC,bs='cs')",
                  "s(DR,bs='cs')",
                  "s(depth,bs='cs')")
                  
The two objects `variants.pa` and `variants.ab` are the variants for the presence-absence (`pa`) and abundance-given-presence (`ab`) submodels, respectively. You can specify any type of structure as long as it respects the `mgcv` R-package syntax (i.e. GAM framework).

Now we can fit the Hurdle model using the function `dshm_fit`:

    H_m<-dshm_fit(det.fn=mod_hr,
             obsdata=obsdata,
             segdata=cor_seg_final@data,
             grid=grid_final@data,
             effects.pa = effects.pa,
             effects.ab = effects.ab)
             
The function prints automatically a model selection table for both presence-absence and abundance submodels. It also prints the selected variant IDs for each submodel. All the relevant information is accessible through the `H_m` object. All fitted presence-absence and abundance submodel variants can be accessed through `H_m$models$pa` and `H_m$models$ab`, respectively. Selected submodel variant IDs are accessible through `H_m$info$ID.pa` and `H_m$info$ID.ab`. If we thus want pick up the best presence-absence submodel variant we can type `H_m$models$pa[[H_m$info$ID.pa[1]]]`.

## Model Relationships

You can easily explore the relationships of both dolphin probability of presence and dolphin abundance with covariates using:

    plot(H_m$models$pa[[H_m$info$ID.pa[1]]],select=1,shade=TRUE)
    plot(H_m$models$ab[[H_m$info$ID.ab[1]]],select=1,shade=TRUE)

```{r, echo=FALSE, out.width = "300px", fig.show='hold',fig.height=6,fig.width=6}
plot(H_m$models$pa[[H_m$info$ID.pa[1]]],select=1,shade=TRUE, main = "Presence-absence")
plot(H_m$models$ab[[H_m$info$ID.ab[1]]],select=1,shade=TRUE, main = "Abundance")
```

Note that y-axis is on linear predictor scale.

## Model Diagnostics
        
You can run the model diagnostics as follows:

    dshm_diagnostics(model = H_m,
                 plot = TRUE,
                 plot.n = 2)
                 
The function `dshm_diagnostics` yields two plots:

- EDF (empirical distribution functin) vs. CDF (cumulative distribution function). For a good fir the points on the EDF vs. CDF plot should be on the diagonal.
- Fitted vs. observed values.

The function also calculates KS statistics, where KS p-value should be above 0.1 for a good fit.

## Model Predictions

You can then plot the Hurdle model predictions on the prediction grid using the function `dshm_plot`:

    dshm_plot(prediction = H_m$grid_data$H,
          grid = grid_final,
          cex = 4,
          scale_col = c("lightblue","blue","yellow","orange","red","red"),
          scale_val = c(0,1,1.5,2,3.5,4))
          
The function `dshm_plot` allows to quickly explore the Hurdle model prodictions. However, note that the plot does not repsect the projection and real dimensions, the function is only intented for a quick exploration. You can quickly change the color scale and intervals for each color using the arguments `scale_col` and `scale_val`. In this example I chose 5 colours and intervals:

- more than 0 is lightblue
- more than 1 is blue
- more than 1.5 is yellow
- more than 2 is orange
- between 3.5 and 4 is red

Note that predictions that are > 4 they will remain uncoloured. So it is important that you put a value that is bigger than your maximum.

After exploring different colours and intervals you can decide to save the grid as a raster image by setting the `saveRaster = TRUE` and by specifying the `raster_name`. Let's say we decide `raster_name = "Hurdle dolphin"`, this will save the raster as a .tif image with the name `Hurdle dolphin.tif` in your working directory.

You can then plot the raster image by typing:

    raster::plot(raster::raster("Hurdle dolphin.tif"),
            col=colorRampPalette(c("lightblue","blue","yellow","red"))(20))
    raster::plot(land_crop, add = TRUE, col = "grey")
   
```{r, echo=FALSE, out.width = "300px", fig.show='hold',fig.height=6,fig.width=6}
raster::plot(pred,main="Predictions (dolphins per cell)",axes=FALSE,col=colorRampPalette(c("lightblue","blue","yellow","red"))(20))
raster::plot(land_crop,col="grey",add=TRUE)
```

Compared to `dshm_plot`, plotting the predictions as a raster image will preserve projection and real dimensions. Moreover, you can easily import the raster in other GIS software sich as ArcGIS and QGIS.

## Confidence Intervals

You estimate prediction grid confidence intervals using the function `dshm_boot`. The function is based on a non-parametric bootstrap and uses the same submodel variant weight and knot locations from `H_m`. It is strongly recommended to run the function in parallel. Depending on the number variants for each submodel and the size of the predictin grid, the code will require from 30 min to a few hours to do 1000 simulations. On my computer it tool 13 minutes on 7 cores.

    boot<-dshm_boot(det.fn.par=list(transect="line",key="hr",
                                adjustment=NULL,formula=~1,
                                truncation = max(obsdata$distance)),
                   effects.pa = variants.pa,
                   effects.ab = variants.ab,
                   distdata = obsdata,
                   obsdata = obsdata,
                   segdata = cor_seg_final@data,
                   grid = grid_final@data, 
                   model_fit = H_m,
                   nsim = 1000,
                   parallel = TRUE,
                   ncores = 7)
                   
The function uses a resampling with replacement and as a consequence if the survey area is big (not this case) this might lead to spatial inconsistency. For big areas it spossible to restrict the resampling to transect line or stratum by setting `stratification = "transect"` or `stratification = "stratum"`.

Obviously, not all the 1000 simulations will be successful due to the fact that the model fit may fail with some dataset generated after resampling. After finishing all simulation the function will print the number of available simulations and display the message:

 > Would you like to continue (Yes/No)?
 
If the number of available simulations is very low it is recommended to type `No` and repeat the process increasing `nsim`. It is also recommended that before putting a very high `nsim`, try with just 20-30 simulations to see if the code works with your data. If you accept the available simulations the function will ask:

 > Would you like to choose a limit for the amount of animals per grid cell (Yes/No)?

Here you can decide if you would like to drop simulations with huge numbers. We encourage to always choose `No` unless you have clear and strong biological / statistical reasons.

After answering to the second question the `boot` object is saved on your workspace. My `boot` object contained 492 simulations, so approximately 50% of the simulations failed. For each simulation the object contains the prediction grid (`boot$sim_grids`) as well as fitted values and observations (`boot$obs_fit`).

We can write a function to calculate lower and upper confidence intervals:

    ci <- function(x,type){
            if (type == "lwr") {
              ci<-quantile(x,probs = 0.025,na.rm = TRUE)
            } else {
              ci<-quantile(x,probs = 0.975,na.rm = TRUE)
            }
          }

We can the use the `ci` function to calculate lower and upper CIs as follows:
    
    lwr.int<-apply(boot$sim_grids,1,ci,type="lwr")
    upr.int<-apply(boot$sim_grids,1,ci,type="upr")
    
Then we use the `dshm_plot` function to plot the upper and lower CIs and to save them as raster images.

    dshm_plot(prediction = lwr.int,
          grid = grid_final,
          cex = 4,
          scale_col = c("lightblue","blue","yellow","orange","red","red"),
          scale_val = c(0,1,1.5,2,3.5,4),
          saveRaster = TRUE,
          raster_name = "lwr Dolphin")

You can then repeat the same code for `upr.int` and plot the two raster images for lower and upper CIs together with point estimate:

    raster::plot(pred_lwr,
            main="Lower CI (dolphins per cell)",
            axes=FALSE,col=colorRampPalette(c("lightblue","blue","yellow","red"))(100),
            zlim=c(0,max(na.omit(pred_upr[]))))
    raster::plot(land_crop,col="grey",add=TRUE)
    raster::plot(pred,
            main="Point estimate (dolphins per cell)",
            axes=FALSE,col=colorRampPalette(c("lightblue","blue","yellow","red"))(100),
            zlim=c(0,max(na.omit(pred_upr[]))))
    raster::plot(land_crop,col="grey",add=TRUE)
    raster::plot(pred_upr,
            main="Upper CI (dolphins per cell)",
            axes=FALSE,col=colorRampPalette(c("lightblue","blue","yellow","red"))(100),
            zlim=c(0,max(na.omit(pred_upr[]))))
    raster::plot(land_crop,col="grey",add=TRUE)

```{r, echo=FALSE, out.width = "300px", fig.show='hold',fig.height=6,fig.width=6}
raster::plot(pred_lwr,main="Lower CI (dolphins per cell)",axes=FALSE,col=colorRampPalette(c("lightblue","blue","yellow","red"))(100),zlim=c(0,max(na.omit(pred_upr[]))))
raster::plot(land_crop,col="grey",add=TRUE)
raster::plot(pred,main="Point estimate (dolphins per cell)",axes=FALSE,col=colorRampPalette(c("lightblue","blue","yellow","red"))(100),zlim=c(0,max(na.omit(pred_upr[]))))
raster::plot(land_crop,col="grey",add=TRUE)
raster::plot(pred_upr,main="Upper CI (dolphins per cell)",axes=FALSE,col=colorRampPalette(c("lightblue","blue","yellow","red"))(100),zlim=c(0,max(na.omit(pred_upr[]))))
raster::plot(land_crop,col="grey",add=TRUE)
```

Note that all plots are on the same colour scale. You can easily set the same color scale also using `dshm_plot`.

## Spatial Correlation

We calculate spatial correlation with distance using the function `dshm_spatial_correlation` as follows:

    dshm_spatial_correlation(coord = sp::coordinates(cor_seg_final),
    z = H_m$residuals, xlab = "Distance (km)",
    ylab = "Correlation", lims = c(-0.2,0.2))

The function yields a plot for correlation coefficient vs. distance in km and calculates the percentage of data that is between a minimum and maximum correlation value defined by the user through the argument `lims`.


